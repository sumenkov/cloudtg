# CloudTG

## Скачать и запустить (для ленивых)
- Windows (portable `.zip`): [CloudTG-windows-portable-x86_64.zip](https://github.com/sumenkov/cloudtg/releases/latest/download/CloudTG-windows-portable-x86_64.zip)
- Linux (`.AppImage`): [CloudTG-linux-x86_64.AppImage](https://github.com/sumenkov/cloudtg/releases/latest/download/CloudTG-linux-x86_64.AppImage)
- macOS Intel (`.dmg`): [CloudTG-macos-x86_64.dmg](https://github.com/sumenkov/cloudtg/releases/latest/download/CloudTG-macos-x86_64.dmg)
- macOS Apple Silicon (`.dmg`): [CloudTG-macos-aarch64.dmg](https://github.com/sumenkov/cloudtg/releases/latest/download/CloudTG-macos-aarch64.dmg)
- Все релизы: [github.com/sumenkov/cloudtg/releases](https://github.com/sumenkov/cloudtg/releases)

Приложение, которое превращает Telegram в понятное файловое хранилище с папками.
Файлы хранятся в Telegram, а на компьютере сохраняются база и локальные копии для быстрого открытия.

## Что умеет программа
- Хранит файлы в Telegram-канале CloudTG.
- Показывает папки и файлы как в обычном файловом менеджере.
- Загружает, скачивает и открывает файлы.
- Не делает лишние копии локальных файлов:
  - если файл уже скачан, перед повторной загрузкой спрашивает перезапись;
  - кнопка «Открыть папку» появляется только у уже скачанного файла.
- Перемещает и удаляет файлы, удаляет пустые папки.
- Отправляет файл в любой чат через действие «Поделиться».
- Ищет файлы по имени и расширению.
- Восстанавливает битые файлы/папки после проверок.
- Делает бэкап базы в канал CloudTG Backups и умеет восстанавливать.
- Автоматически подготавливает TDLib (поиск, скачивание или сборка).

## Если вы открыли программу впервые
1. Нажмите `Настройки` в правом верхнем углу.
2. В блоке `Подключение Telegram` заполните `API_ID` и `API_HASH`, затем нажмите `Сохранить подключение`.
3. Пройдите авторизацию Telegram.
4. Вернитесь на главный экран и нажмите `Обновить сейчас`.
5. Слева выберите папку, справа откройте вкладку `Файлы`.

## Интерфейс простыми словами
### Главное окно
- `Настройки`: подключение Telegram, обслуживание, бэкапы и восстановление.
- `Обновить из Telegram` -> кнопка `Обновить сейчас`: подтягивает новые сообщения из канала и обновляет дерево.
- `Как начать работу`: короткая памятка по первым действиям.

### Рабочая область
- Слева: дерево папок.
- Справа: вкладки `Файлы`, `Папки`, `Поиск`, `Сервис`.
- Если выбрана папка `Корень`, вкладки `Файлы` и `Поиск` неактивны (серые). Это нормальное поведение.

### Вкладка «Файлы»
- `Выбрать и загрузить`: загрузка файлов в выбранную папку.
- Основная кнопка у файла:
  - `Скачать`, если локальной копии нет;
  - `Открыть`, если локальная копия уже есть.
- Меню `⋯ Действия`:
  - `Открыть (скачается)`,
  - `Скачать заново`,
  - `Открыть папку`,
  - `Поделиться`,
  - `Восстановить` (только для битых файлов),
  - `Удалить`.

### Вкладка «Папки»
- Создание, переименование, перемещение папок.
- Удаление только пустой папки.

### Вкладка «Поиск»
- Поиск по имени и/или расширению.
- Можно искать в текущей папке или сразу во всех.

### Вкладка «Сервис»
- Подсказка, где искать обслуживание хранилища и бэкапы (`Настройки`).
- Кнопка `Восстановить папку` для битой выбранной папки.

## Технологии
- UI: React + Vite
- Desktop: Tauri
- Backend: Rust
- Локальная БД: SQLite + миграции (`src-tauri/migrations`)
- Метаданные в Telegram: теги `#ocltg #v1` (модуль `fsmeta`)
- Портативность: по умолчанию рядом с бинарём (`./data`, `./cache`, `./logs`), на Linux/macOS при отсутствии прав — пользовательские директории

> Для реальной работы с Telegram нужен TDLib (libtdjson).
> API_ID и API_HASH можно сохранить в системном хранилище ключей или в зашифрованном файле с паролем.
> Также доступен режим «вводить каждый запуск».
> Переменные окружения `CLOUDTG_API_ID` и `CLOUDTG_API_HASH` используются только для dev/CI
> (можно задать при запуске; для удобства есть `.env.example`).
> При сборке можно **вшить ключи**, если задать `CLOUDTG_EMBED_API_KEYS=1`.
> Путь к TDLib задаётся в настройках и хранится в локальной базе.
> Если путь к TDLib не указан и библиотека не найдена, приложение попробует скачать предсобранную TDLib из релиза
> (по `tdlib-manifest.json`), а если не получится — соберёт её в `./third_party/tdlib`.
> Для автосборки нужны `git`, `cmake` и C/C++ toolchain, установленные в системе.

## Предсобранная TDLib (быстрый запуск без сборки)
Чтобы приложение запускалось сразу, положи `libtdjson` в ресурсы приложения:

```
src-tauri/resources/tdlib/<os>-<arch>/libtdjson.*
```

Примеры:
- Windows: `src-tauri/resources/tdlib/windows-x86_64/tdjson.dll`
- macOS (Apple Silicon): `src-tauri/resources/tdlib/macos-aarch64/libtdjson.dylib`
- Ubuntu Linux: `src-tauri/resources/tdlib/linux-x86_64/libtdjson.so`

Поддерживаются также папки `tdlib/<os>` и просто `tdlib/`.
При запуске приложение сначала ищет библиотеку в ресурсах и рядом с бинарём, и только затем запускает автосборку.

## CI артефакты TDLib
В репозитории есть workflow `Сборка TDLib (prebuilt)` — он собирает TDLib под Windows/macOS/Linux,
публикует архивы в релиз и генерирует `tdlib-manifest.json` с checksum и ссылками.

## Скачать предсобранную TDLib автоматически
Linux/macOS:
```bash
./scripts/fetch-tdlib.sh
```

Windows (PowerShell):
```powershell
.\scripts\fetch-tdlib.ps1
```

Через npm (автоопределение ОС):
```bash
npm run tdlib:fetch
```

Если библиотека уже есть в `src-tauri/resources/tdlib`, скрипт просто сообщит путь и ничего не скачает.

Скрипты берут файлы из последнего релиза GitHub и используют `tdlib-manifest.json`
для выбора архива и проверки checksum.
Для автоскачивания в приложении можно указать
`CLOUDTG_TDLIB_REPO=owner/repo` или прямую ссылку `CLOUDTG_TDLIB_MANIFEST_URL`.
По умолчанию приложение берёт репозиторий из метаданных сборки (в этом репозитории — `sumenkov/cloudtg`).
Если репозиторий не определяется автоматически, задай переменную:
`CLOUDTG_TDLIB_REPO=owner/repo`.
Можно также указать прямую ссылку на манифест:
`CLOUDTG_TDLIB_MANIFEST_URL=https://.../tdlib-manifest.json`.
Для приватных репозиториев добавь `GITHUB_TOKEN` или `GH_TOKEN`.

## Быстрая установка зависимостей для автосборки TDLib
- Ubuntu/Debian:
  ```bash
  sudo apt-get install git cmake gperf build-essential
  ```
- Arch:
  ```bash
  sudo pacman -S git cmake gperf base-devel
  ```
- macOS (Homebrew):
  ```bash
  brew install git cmake gperf
  ```
- Windows (MSYS2):
  ```powershell
  pacman -S mingw-w64-x86_64-gperf mingw-w64-x86_64-cmake git
  ```

## Быстрый старт (dev)

### 1) Установи зависимости
- Node.js 18+ (или 20+)
- Rust stable (edition 2021)

#### Системные зависимости Tauri (Linux/macOS/Windows)
Linux (Debian/Ubuntu):  
```bash
sudo apt update
sudo apt install -y pkg-config libglib2.0-dev libgtk-3-dev libwebkit2gtk-4.1-dev libayatana-appindicator3-dev librsvg2-dev patchelf
```
Если видишь ошибку вида `glib-sys ... pkg-config`, значит не хватает `pkg-config` и/или `libglib2.0-dev`.

macOS:  
```bash
xcode-select --install
```
Если сборка ругается на `pkg-config`, установи:
```bash
brew install pkg-config
```

Windows 10/11:  
- Нужен WebView2 Runtime (обычно уже установлен в системе).
- Нужны Visual Studio Build Tools с компонентом C++ и Windows SDK.
- Через winget можно поставить инсталлер Build Tools:
```powershell
winget install Microsoft.VisualStudio.2022.BuildTools
```

#### npm (нужен для сборки и запуска)
Проект использует npm‑скрипты, поэтому нужен `npm` (он идёт вместе с Node.js).

Linux (Debian/Ubuntu):  
```bash
sudo apt update
sudo apt install -y nodejs npm
```

macOS (Homebrew):  
```bash
brew install node
```

Windows 10/11:  
Официальный установщик Node.js (LTS) **или** через winget:
```powershell
winget install OpenJS.NodeJS.LTS
```

Проверь установку:
```bash
node -v
npm -v
```

#### Rust (cargo нужен для Tauri)
Tauri использует Rust toolchain и команду `cargo`. Установи Rust stable.

Linux (Debian/Ubuntu):  
```bash
sudo apt update
sudo apt install -y curl build-essential
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source "$HOME/.cargo/env"
```

macOS (Homebrew):  
```bash
brew install rustup-init
rustup-init -y
source "$HOME/.cargo/env"
```

Windows 10/11:  
Официальный rustup‑инсталлер **или** через winget:
```powershell
winget install Rustlang.Rustup
```

Проверь установку:
```bash
cargo --version
```

### 2) Запусти
```bash
# в корне проекта
npm install
npm run tauri:dev
```

Откроется окно CloudTG. При первом запуске создадутся папки рядом с бинарём
(если нет прав — см. разделы «Данные и кеш» и «Логи»):
- `./data` (SQLite: `cloudtg.sqlite`)
- `./cache`
- `./logs`

## Настройки: где какая кнопка
В `Настройки` кнопки сгруппированы по блокам.

`Подключение Telegram`:
- **Сохранить подключение** — сохраняет `API_ID/API_HASH` и путь к TDLib.
- **Проверить связь с Telegram** — отправляет тестовое сообщение в канал CloudTG.

`Обслуживание хранилища`:
- **Запустить проверку** — проверяет последние сообщения канала хранения и помечает битые записи.
- **Создать бэкап** — отправляет SQLite-базу в канал **CloudTG Backups**.
- **Открыть канал бэкапов** — открывает канал **CloudTG Backups** в Telegram.

`Опасные действия`:
- **Восстановить базу из бэкапа** — использует последний бэкап или пересобирает базу из канала; после этого перезапустите приложение.
- **Создать новый канал CloudTG** — создаёт новый канал хранения и переносит структуру из текущей базы.

## Обновление из Telegram
На главном экране есть блок **Обновить из Telegram** и кнопка **Обновить сейчас**.

- По кнопке приложение считывает новые сообщения из канала хранения и обновляет дерево файлов.
- Это же обновление запускается автоматически при старте и периодически в фоне.
- Файлы, добавленные вручную в канал:
  - без тегов попадают в папку «Неразобранное»;
  - с хештегом папки попадают в нужную папку (или папка создаётся автоматически).

## Поиск
Во вкладке **Поиск** можно искать по имени и/или расширению:
- в текущей папке;
- сразу во всех папках.

## Работа с локальными копиями
- Кнопка **Скачать**:
  - если локальной копии нет, файл скачивается;
  - если копия уже есть, приложение предложит **перезаписать** файл или **отменить** действие.
- Кнопка **Открыть**:
  - если локальная копия есть, она открывается сразу;
  - если копии нет, файл сначала скачивается, затем открывается.
- Кнопка **Открыть папку**:
  - отображается только для уже скачанных файлов;
  - открывает папку с локальной копией, без повторного скачивания.
- Удаление файла:
  - удаляет сообщение в канале хранения и запись в SQLite;
  - если локальная копия существует, она удаляется с диска без помещения в отдельную корзину.
- Размер файла в списке:
  - `0 Б`, если файл еще не скачан локально;
  - фактический локальный размер после скачивания.

## Битые файлы и папки
Если сообщение в канале хранения удалено или недоступно, запись помечается как «битая»
(обычно после проверки целостности).

- Для папок используйте «Восстановить папку» — пересоздаёт/обновляет сообщение папки в канале хранения.
- Для файлов используйте «Восстановить» — пытается найти сообщение,
  а если требуется, попросит выбрать локальный файл для повторной отправки.

## Бэкап и восстановление
Бэкап — это файл SQLite, отправленный в отдельный канал **CloudTG Backups**.

- При восстановлении используется **последний** бэкап.
- Если бэкап не найден или он **старее** последних сообщений в канале хранения,
  приложение пересобирает базу из канала хранения.
- Применение восстановления требует **перезапуска** приложения.

## Данные и кеш
На Linux/macOS используется общая директория хранения. Если рядом с бинарём нет прав на запись,
приложение переносит `data/cache/logs` в пользовательский каталог:
- Linux: `$XDG_DATA_HOME/cloudtg` → `~/.local/share/cloudtg`
- macOS: `~/Library/Application Support/CloudTG`

Путь можно задать вручную через переменную `CLOUDTG_STORAGE_DIR` (Linux/macOS).
На Windows всё остаётся рядом с бинарём.

## Логи
Логи пишутся в папку `./logs` в формате **JSON Lines** (одна JSON‑строка на событие).
Файл имеет вид `cloudtg.jsonl.YYYY-MM-DD` и подходит для последующего парсинга.
На Linux/macOS логи хранятся вместе с `data/cache` в общей директории
(см. раздел «Данные и кеш»). Путь можно задать через `CLOUDTG_STORAGE_DIR`.

## Безопасность и хранение ключей
### Threat model (явно)
**Защищаемые активы**
- `API_ID` и `API_HASH`.
- Локальная Telegram-сессия TDLib и служебные данные приложения.
- Локальные копии файлов в `cache/downloads`.
- Метаданные структуры в SQLite (имена, дерево, `tg_chat_id`, `tg_msg_id`).

**Границы доверия**
- Доверенная зона: текущий пользователь ОС, локальная ФС с корректными правами, системное хранилище ключей ОС.
- Недоверенная зона: сеть, внешние репозитории/релизы, любые третьи лица с доступом к бинарнику или рабочей директории.

**Модель нарушителя**
- Имеет доступ к репозиторию, артефакту сборки или логам.
- Имеет чтение пользовательских файлов (или запускает процесс от имени пользователя).
- Не имеет контроля над вашим Telegram-аккаунтом по умолчанию.

**Что делаем для защиты**
- `API_ID/API_HASH` не хранятся в SQLite.
- Ключи можно хранить в системном keychain (`keyring`) или в зашифрованном файле:
  `data/secrets/tg_keys.enc.json`.
- Для шифрования используется KDF Argon2 + `XChaCha20-Poly1305` (AEAD).
- Запись зашифрованного файла выполняется атомарно (`write + rename`), на Unix выставляются права `0600`.
- Режим хранения `только в текущем запуске` не пишет ключи на диск.

**Что не покрывается этим threat model**
- Компрометация хоста (malware, keylogger, дамп памяти, root/admin-доступ).
- Утечка ключей из переменных окружения, CI-логов или истории shell.
- Обратная инженерия бинарника при сборке с `CLOUDTG_EMBED_API_KEYS=1`
  (вшитые ключи считаются публичными).
- Риски Telegram-каналов при ошибочной выдаче доступа посторонним.

**Практические рекомендации**
- Для постоянного использования выбирай `system keychain` или `encrypted file` с сильным паролем.
- Не используй `CLOUDTG_EMBED_API_KEYS=1` в продакшн-сборках.
- Для dev/CI через env не публикуй значения в логах, `.env`, скриншотах и issue.
- Если есть подозрение на утечку, перевыпусти `API_HASH` на `my.telegram.org`.
- Ограничь доступ к каналам CloudTG и CloudTG Backups только доверенными участниками.

## Как получить API_ID и API_HASH Telegram
1) Открой сайт `my.telegram.org` и войди по номеру телефона.
2) Перейди в раздел **API development tools**.
3) Создай новое приложение (любое имя/описание).
4) Скопируй значения **API ID** и **API Hash**.
5) Введи их в настройках приложения и выбери способ хранения:
   системное хранилище ключей, зашифрованный файл или только текущий запуск.
   Для dev/CI можно задать их через `CLOUDTG_API_ID` и `CLOUDTG_API_HASH`
   (например, в `.env` на основе `.env.example`).

Важно: не публикуй API_HASH и не добавляй его в репозиторий.
Важно: если ключи **вшиты в приложение**, их можно извлечь. Считай их публичными.

### Варианты сборки
**Сборка без вшитых ключей (по умолчанию)**  
Ключи вводятся в приложении и сохраняются в системном хранилище или в зашифрованном файле.
Для dev/CI можно передать их через env или `.env` рядом с приложением.
Пример:
```bash
CLOUDTG_API_ID=123 CLOUDTG_API_HASH=... ./cloudtg
```

**Сборка с вшитыми ключами**  
Перед сборкой задай:
- `CLOUDTG_EMBED_API_KEYS=1`
- `CLOUDTG_API_ID`, `CLOUDTG_API_HASH`

Важно: вшитые ключи можно извлечь из бинарника — считай их публичными.

Пример:
```bash
CLOUDTG_EMBED_API_KEYS=1 CLOUDTG_API_ID=123 CLOUDTG_API_HASH=... npm run tauri:build
```
Если ключи уже в `.env`, можно так:
```bash
CLOUDTG_EMBED_API_KEYS=1 npm run tauri:build
```

## Тесты

Rust:
```bash
npm run rust:test
```

UI:
```bash
npm test
```

Проверка покрытия UI-тестов (опционально):
```bash
npm --workspace ui run test -- --coverage
```
Для этой команды нужен пакет `@vitest/coverage-v8`.

## Сборка portable
```bash
npm run tauri:build
```

## Формат тегов (fsmeta)

Файл (caption):
`#ocltg #v1 #file d=<dirId> f=<fileId> n=<name> h=<hashShort>`

Директория (text msg):
`#ocltg #v1 #dir d=<dirId> p=<ROOT|parentId> name=<folderName>`
